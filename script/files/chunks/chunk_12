lugin extends NetworkPlugin{address;targetNetwork;constructor(address,targetNetwork){super("org.ethers.plugins.network.Ens");defineProperties(this,{address:address||EnsAddress,targetNetwork:targetNetwork==null?1:targetNetwork})}clone(){return new EnsPlugin(this.address,this.targetNetwork)}}class FeeDataNetworkPlugin extends NetworkPlugin{#feeDataFunc;get feeDataFunc(){return this.#feeDataFunc}constructor(feeDataFunc){super("org.ethers.plugins.network.FeeData");this.#feeDataFunc=feeDataFunc}async getFeeData(provider){return await this.#feeDataFunc(provider)}clone(){return new FeeDataNetworkPlugin(this.#feeDataFunc)}}const Networks=new Map;class Network{#name;#chainId;#plugins;constructor(name,chainId){this.#name=name;this.#chainId=getBigInt(chainId);this.#plugins=new Map}toJSON(){return{name:this.name,chainId:this.chainId}}get name(){return this.#name}set name(value){this.#name=value}get chainId(){return this.#chainId}set chainId(value){this.#chainId=getBigInt(value,"chainId")}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.clone());return this}getPlugin(name){return this.#plugins.get(name)||null}getPlugins(basename){return this.plugins.filter(p=>p.name.split("#")[0]===basename)}clone(){const clone=new Network(this.name,this.chainId);this.plugins.forEach(plugin=>{clone.attachPlugin(plugin.clone())});return clone}computeIntrinsicGas(tx){const costs=this.getPlugin("org.ethers.plugins.network.GasCost")||new GasCostPlugin;let gas=costs.txBase;if(tx.to==null){gas+=costs.txCreate}if(tx.data){for(let i=2;i<tx.data.length;i+=2){if(tx.data.substring(i,i+2)==="00"){gas+=costs.txDataZero}else{gas+=costs.txDataNonzero}}}if(tx.accessList){const accessList=accessListify(tx.accessList);for(const addr in accessList){gas+=costs.txAccessListAddress+costs.txAccessListStorageKey*accessList[addr].storageKeys.length}}return gas}static from(network){injectCommonNetworks();if(network==null){return Network.from("mainnet")}if(typeof network==="number"){network=BigInt(network)}if(typeof network==="string"||typeof network==="bigint"){const networkFunc=Networks.get(network);if(networkFunc){return networkFunc()}if(typeof network==="bigint"){return new Network("unknown",network)}assertArgument(false,"unknown network","network",network)}if(typeof network.clone==="function"){const clone=network.clone();return clone}if(typeof network==="object"){assertArgument(typeof network.name==="string"&&typeof network.chainId==="number","invalid network object name or chainId","network",network);const custom=new Network(network.name,network.chainId);if(network.ensAddress||network.ensNetwork!=null){custom.attachPlugin(new EnsPlugin(network.ensAddress,network.ensNetwork))}return custom}assertArgument(false,"invalid network","network",network)}static register(nameOrChainId,networkFunc){if(typeof nameOrChainId==="number"){nameOrChainId=BigInt(nameOrChainId)}const existing=Networks.get(nameOrChainId);if(existing){assertArgument(false,`conflicting network for ${JSON.stringify(existing.name)}`,"nameOrChainId",nameOrChainId)}Networks.set(nameOrChainId,networkFunc)}}let injected=false;function injectCommonNetworks(){if(injected){return}injected=true;function registerEth(name,chainId,options){const func=function(){const network=new Network(name,chainId);if(options.ensNetwork!=null){network.attachPlugin(new EnsPlugin(null,options.ensNetwork))}if(options.priorityFee){}network.attachPlugin(new GasCostPlugin);return network};Network.register(name,func);Network.register(chainId,func);if(options.altNames){options.altNames.forEach(name=>{Network.register(name,func)})}}registerEth("mainnet",1,{ensNetwork:1,altNames:["homestead"]});registerEth("ropsten",3,{ensNetwork:3});registerEth("rinkeby",4,{ensNetwork:4});registerEth("goerli",5,{ensNetwork:5});registerEth("kovan",42,{ensNetwork:42});registerEth("sepolia",11155111,{});registerEth("classic",61,{});registerEth("classicKotti",6,{});registerEth("xdai",100,{ensNetwork:1});registerEth("optimism",10,{ensNetwork:1,etherscan:{url:"https://api-optimistic.etherscan.io/"}});registerEth("optimism-goerli",420,{etherscan:{url:"https://api-goerli-optimistic.etherscan.io/"}});registerEth("arbitrum",42161,{ensNetwork:1,etherscan:{url:"https://api.arbiscan.io/"}});registerEth("arbitrum-goerli",421613,{etherscan:{url:"https://api-goerli.arbiscan.io/"}});registerEth("matic",137,{ensNetwork:1,etherscan:{url:"https://api.polygonscan.com/"}});registerEth("matic-mumbai",80001,{altNames:["maticMumbai","maticmum"],etherscan:{url:"https://api-testnet.polygonscan.com/"}});registerEth("bnb",56,{ensNetwork:1,etherscan:{url:"http://api.bscscan.com"}});registerEth("bnbt",97,{etherscan:{url:"http://api-testnet.bscscan.com"}})}function copy$2(obj){return JSON.parse(JSON.stringify(obj))}function getPollingSubscriber(provider,event){if(event==="block"){return new PollingBlockSubscriber(provider)}if(isHexString(event,32)){return new PollingTransactionSubscriber(provider,event)}assert$1(false,"unsupported polling event","UNSUPPORTED_OPERATION",{operation:"getPollingSubscriber",info:{event:event}})}class PollingBlockSubscriber{#provider;#poller;#interval;#blockNumber;constructor(provider){this.#provider=provider;this.#poller=null;this.#interval=4e3;this.#blockNumber=-2}get pollingInterval(){return this.#interval}set pollingInterval(value){this.#interval=value}async#poll(){try{const blockNumber=await this.#provider.getBlockNumber();if(this.#blockNumber===-2){this.#blockNumber=blockNumber;return}if(blockNumber!==this.#blockNumber){for(let b=this.#blockNumber+1;b<=blockNumber;b++){if(this.#poller==null){return}await this.#provider.emit("block",b)}this.#blockNumber=blockNumber}}catch(error){}if(this.#poller==null){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval)}start(){if(this.#poller){return}this.#poller=this.#provider._setTimeout(this.#poll.bind(this),this.#interval);this.#poll()}stop(){if(!this.#poller){return}this.#provider._clearTimeout(this.#poller);this.#poller=null}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}class OnBlockSubscriber{#provider;#poll;#running;constructor(provider){this.#provider=provider;this.#running=false;this.#poll=blockNumber=>{this._poll(blockNumber,this.#provider)}}async _poll(blockNumber,provider){throw new Error("sub-classes must override this")}start(){if(this.#running){return}this.#running=true;this.#poll(-2);this.#provider.on("block",this.#poll)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off("block",this.#poll)}pause(dropWhilePaused){this.stop()}resume(){this.start()}}class PollingOrphanSubscriber extends OnBlockSubscriber{#filter;constructor(provider,filter){super(provider);this.#filter=copy$2(filter)}async _poll(blockNumber,provider){throw new Error("@TODO");console.log(this.#filter)}}class PollingTransactionSubscriber extends OnBlockSubscriber{#hash;constructor(provider,hash){super(provider);this.#hash=hash}async _poll(blockNumber,provider){const tx=await provider.getTransactionReceipt(this.#hash);if(tx){provider.emit(this.#hash,tx)}}}class PollingEventSubscriber{#provider;#filter;#poller;#running;#blockNumber;constructor(provider,filter){this.#provider=provider;this.#filter=copy$2(filter);this.#poller=this.#poll.bind(this);this.#running=false;this.#blockNumber=-2}async#poll(blockNumber){if(this.#blockNumber===-2){return}const filter=copy$2(this.#filter);filter.fromBlock=this.#blockNumber+1;filter.toBlock=blockNumber;const logs=await this.#provider.getLogs(filter);if(logs.length===0){if(this.#blockNumber<blockNumber-60){this.#blockNumber=blockNumber-60}return}this.#blockNumber=blockNumber;for(const log of logs){this.#provider.emit(this.#filter,log)}}start(){if(this.#running){return}this.#running=true;if(this.#blockNumber===-2){this.#provider.getBlockNumber().then(blockNumber=>{this.#blockNumber=blockNumber})}this.#provider.on("block",this.#poller)}stop(){if(!this.#running){return}this.#running=false;this.#provider.off("block",this.#poller)}pause(dropWhilePaused){this.stop();if(dropWhilePaused){this.#blockNumber=-2}}resume(){this.start()}}const BN_2$1=BigInt(2);const MAX_CCIP_REDIRECTS=10;function isPromise$1(value){return value&&typeof value.then==="function"}function getTag(prefix,value){return prefix+":"+JSON.stringify(value,(k,v)=>{if(v==null){return"null"}if(typeof v==="bigint"){return`bigint:${v.toString()}`}if(typeof v==="string"){return v.toLowerCase()}if(typeof v==="object"&&!Array.isArray(v)){const keys=Object.keys(v);keys.sort();return keys.reduce((accum,key)=>{accum[key]=v[key];return accum},{})}return v})}class UnmanagedSubscriber{name;constructor(name){defineProperties(this,{name:name})}start(){}stop(){}pause(dropWhilePaused){}resume(){}}function copy$1(value){return JSON.parse(JSON.stringify(value))}function concisify(items){items=Array.from(new Set(items).values());items.sort();return items}async function getSubscription(_event,provider){if(_event==null){throw new Error("invalid event")}if(Array.isArray(_event)){_event={topics:_event}}if(typeof _event==="string"){switch(_event){case"block":case"pending":case"debug":case"network":{return{type:_event,tag:_event}}}}if(isHexString(_event,32)){const hash=_event.toLowerCase();return{type:"transaction",tag:getTag("tx",{hash:hash}),hash:hash}}if(_event.orphan){const event=_event;return{type:"orphan",tag:getTag("orphan",event),filter:copy$1(event)}}if(_event.address||_event.topics){const event=_event;const filter={topics:(event.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()})};if(event.address){const addresses=[];const promises=[];const addAddress=addr=>{if(isHexString(addr)){addresses.push(addr)}else{promises.push((async()=>{addresses.push(await resolveAddress(addr,provider))})())}};if(Array.isArray(event.address)){event.address.forEach(addAddress)}else{addAddress(event.address)}if(promises.length){await Promise.all(promises)}filter.address=concisify(addresses.map(a=>a.toLowerCase()))}return{filter:filter,tag:getTag("event",filter),type:"event"}}assertArgument(false,"unknown ProviderEvent","event",_event)}function getTime$1(){return(new Date).getTime()}class AbstractProvider{#subs;#plugins;#pausedState;#networkPromise;#anyNetwork;#performCache;#lastBlockNumber;#nextTimer;#timers;#disableCcipRead;constructor(_network){if(_network==="any"){this.#anyNetwork=true;this.#networkPromise=null}else if(_network){const network=Network.from(_network);this.#anyNetwork=false;this.#networkPromise=Promise.resolve(network);setTimeout(()=>{this.emit("network",network,null)},0)}else{this.#anyNetwork=false;this.#networkPromise=null}this.#lastBlockNumber=-1;this.#performCache=new Map;this.#subs=new Map;this.#plugins=new Map;this.#pausedState=null;this.#nextTimer=1;this.#timers=new Map;this.#disableCcipRead=false}get provider(){return this}get plugins(){return Array.from(this.#plugins.values())}attachPlugin(plugin){if(this.#plugins.get(plugin.name)){throw new Error(`cannot replace existing plugin: ${plugin.name} `)}this.#plugins.set(plugin.name,plugin.connect(this));return this}getPlugin(name){return this.#plugins.get(name)||null}get disableCcipRead(){return this.#disableCcipRead}set disableCcipRead(value){this.#disableCcipRead=!!value}async#perform(req){const tag=getTag(req.method,req);let perform=this.#performCache.get(tag);if(!perform){perform=this._perform(req);this.#performCache.set(tag,perform);setTimeout(()=>{if(this.#performCache.get(tag)===perform){this.#performCache.delete(tag)}},250)}return await perform}async ccipReadFetch(tx,calldata,urls){if(this.disableCcipRead||urls.length===0||tx.to==null){return null}const sender=tx.to.toLowerCase();const data=calldata.toLowerCase();const errorMessages=[];for(let i=0;i<urls.length;i++){const url=urls[i];const href=url.replace("{sender}",sender).replace("{data}",data);const request=new FetchRequest(href);if(url.indexOf("{data}")===-1){request.body={data:data,sender:sender}}this.emit("debug",{action:"sendCcipReadFetchRequest",request:request,index:i,urls:urls});let errorMessage="unknown error";const resp=await request.send();try{const result=resp.bodyJson;if(result.data){this.emit("debug",{action:"receiveCcipReadFetchResult",request:request,result:result});return result.data}if(result.message){errorMessage=result.message}this.emit("debug",{action:"receiveCcipReadFetchError",request:request,result:result})}catch(error){}assert$1(resp.statusCode<400||resp.statusCode>=500,`response not found during CCIP fetch: ${errorMessage}`,"OFFCHAIN_FAULT",{reason:"404_MISSING_RESOURCE",transaction:tx,info:{url:url,errorMessage:errorMessage}});errorMessages.push(errorMessage)}assert$1(false,`error encountered during CCIP fetch: ${errorMessages.map(m=>JSON.stringify(m)).join(", ")}`,"OFFCHAIN_FAULT",{reason:"500_SERVER_ERROR",transaction:tx,info:{urls:urls,errorMessages:errorMessages}})}_wrapBlock(value,network){return new Block(formatBlock(value),this)}_wrapLog(value,network){return new Log(formatLog(value),this)}_wrapTransactionReceipt(value,network){return new TransactionReceipt(formatTransactionReceipt(value),this)}_wrapTransactionResponse(tx,network){return new TransactionResponse(formatTransactionResponse(tx),this)}_detectNetwork(){assert$1(false,"sub-classes must implement this","UNSUPPORTED_OPERATION",{operation:"_detectNetwork"})}async _perform(req){assert$1(false,`unsupported method: ${req.method}`,"UNSUPPORTED_OPERATION",{operation:req.method,info:req})}async getBlockNumber(){const blockNumber=getNumber(await this.#perform({method:"getBlockNumber"}),"%response");if(this.#lastBlockNumber>=0){this.#lastBlockNumber=blockNumber}return blockNumber}_getAddress(address){return resolveAddress(address,this)}_getBlockTag(blockTag){if(blockTag==null){return"latest"}switch(blockTag){case"earliest":return"0x0";case"latest":case"pending":case"safe":case"finalized":return blockTag}if(isHexString(blockTag)){if(isHexString(blockTag,32)){return blockTag}return toQuantity(blockTag)}if(typeof blockTag==="bigint"){blockTag=getNumber(blockTag,"blockTag")}if(typeof blockTag==="number"){if(blockTag>=0){return toQuantity(blockTag)}if(this.#lastBlockNumber>=0){return toQuantity(this.#lastBlockNumber+blockTag)}return this.getBlockNumber().then(b=>toQuantity(b+blockTag))}assertArgument(false,"invalid blockTag","blockTag",blockTag)}_getFilter(filter){const topics=(filter.topics||[]).map(t=>{if(t==null){return null}if(Array.isArray(t)){return concisify(t.map(t=>t.toLowerCase()))}return t.toLowerCase()});const blockHash="blockHash"in filter?filter.blockHash:undefined;const resolve=(_address,fromBlock,toBlock)=>{let address=undefined;switch(_address.length){case 0:break;case 1:address=_address[0];break;default:_address.sort();address=_address}if(blockHash){if(fromBlock!=null||toBlock!=null){throw new Error("invalid filter")}}const filter={};if(address){filter.address=address}if(topics.length){filter.topics=topics}if(fromBlock){filter.fromBlock=fromBlock}if(toBlock){filter.toBlock=toBlock}if(blockHash){filter.blockHash=blockHash}return filter};let address=[];if(filter.address){if(Array.isArray(filter.address)){for(const addr of filter.address){address.push(this._getAddress(addr))}}else{address.push(this._getAddress(filter.address))}}let fromBlock=undefined;if("fromBlock"in filter){fromBlock=this._getBlockTag(filter.fromBlock)}let toBlock=undefined;if("toBlock"in filter){toBlock=this._getBlockTag(filter.toBlock)}if(address.filter(a=>typeof a!=="string").length||fromBlock!=null&&typeof fromBlock!=="string"||toBlock!=null&&typeof toBlock!=="string"){return Promise.all([Promise.all(address),fromBlock,toBlock]).then(result=>{return resolve(result[0],result[1],result[2])})}return resolve(address,fromBlock,toBlock)}_getTransactionRequest(_request){const request=copyRequest(_request);const promises=[];["to","from"].forEach(key=>{if(request[key]==null){return}const addr=resolveAddress(request[key]);if(isPromise$1(addr)){promises.push(async function(){request[key]=await addr}())}else{request[key]=addr}});if(request.blockTag!=null){const blockTag=this._getBlockTag(request.blockTag);if(isPromise$1(blockTag)){promises.push(async function(){request.blockTag=await blockTag}())}else{request.blockTag=blockTag}}if(promises.length){return async function(){await Promise.all(promises);return request}()}return request}async getNetwork(){if(this.#networkPromise==null){const detectNetwork=this._detectNetwork().then(network=>{this.emit("network",network,null);return network},error=>{if(this.#networkPromise===detectNetwork){this.#networkPromise=null}throw error});this.#networkPromise=detectNetwork;return(await detectNetwork).clone()}const networkPromise=this.#networkPromise;const[expected,actual]=await Promise.all([networkPromise,this._detectNetwork()]);if(expected.chainId!==actual.chainId){if(this.#anyNetwork){this.emit("network",actual,expected);if(this.#networkPromise===networkPromise){this.#networkPromise=Promise.resolve(actual)}}else{assert$1(false,`network changed: ${expected.chainId} => ${actual.chainId} `,"NETWORK_ERROR",{event:"changed"})}}return expected.clone()}async getFeeData(){const{block,gasPrice}=await resolveProperties({block:this.getBlock("latest"),gasPrice:(async()=>{try{const gasPrice=await this.#perform({method:"getGasPrice"});return getBigInt(gasPrice,"%response")}catch(error){}return null})()});let maxFeePerGas=null,maxPriorityFeePerGas=null;if(block&&block.baseFeePerGas){maxPriorityFeePerGas=BigInt("1000000000");maxFeePerGas=block.baseFeePerGas*BN_2$1+maxPriorityFeePerGas}return new FeeData(gasPrice,maxFeePerGas,maxPriorityFeePerGas)}async estimateGas(_tx){let tx=this._getTransactionRequest(_tx);if(isPromise$1(tx)){tx=await tx}return getBigInt(await this.#perform({method:"estimateGas",transaction:tx}),"%response")}async#call(tx,blockTag,attempt){assert$1(attempt<MAX_CCIP_REDIRECTS,"CCIP read exceeded maximum redirections","OFFCHAIN_FAULT",{reason:"TOO_MANY_REDIRECTS",transaction:Object.assign({},tx,{blockTag:blockTag,enableCcipRead:true})});const transaction=copyRequest(tx);try{return hexlify(await this._perform({method:"call",transaction:transaction,blockTag:blockTag}))}catch(error){if(!this.disableCcipRead&&isCallException(error)&&error.data&&attempt>=0&&blockTag==="latest"&&transaction.to!=null&&dataSlice(error.data,0,4)==="0x556f1830"){const data=error.data;const txSender=await resolveAddress(transaction.to,this);let ccipArgs;try{ccipArgs=parseOffchainLookup(dataSlice(error.data,4))}catch(error){assert$1(false,error.message,"OFFCHAIN_FAULT",{reason:"BAD_DATA",transaction:transaction,info:{data:data}})}assert$1(ccipArgs.sender.toLowerCase()===txSender.toLowerCase(),"CCIP Read sender mismatch","CALL_EXCEPTION",{action:"call",data:data,reason:"OffchainLookup",transaction:transaction,invocation:null,revert:{signature:"OffchainLookup(address,string[],bytes,bytes4,bytes)",name:"OffchainLookup",args:ccipArgs.errorArgs}});const ccipResult=await this.ccipReadFetch(transaction,ccipArgs.calldata,ccipArgs.urls);assert$1(ccipResult!=null,"CCIP Read failed to fetch data","OFFCHAIN_FAULT",{reason:"FETCH_FAILED",transaction:transaction,info:{data:error.data,errorArgs:ccipArgs.errorArgs}});const tx={to:txSender,data:concat([ccipArgs.selector,encodeBytes([ccipResult,ccipArgs.extraData])])};this.emit("debug",{action:"sendCcipReadCall",transaction:tx});try{const result=await this.#call(tx,blockTag,attempt+1);this.emit("debug",{action:"receiveCcipReadCallResult",transaction:Object.assign({},tx),result:result});return result}catch(error){this.emit("debug",{action:"receiveCcipReadCallError",transaction:Object.assign({},tx),error:error});throw error}}throw error}}async#checkNetwork(promise){const{value}=await resolveProperties({network:this.getNetwork(),value:promise});return value}async call(_tx){const{tx,blockTag}=await resolveProperties({tx:this._getTransactionRequest(_tx),blockTag:this._getBlockTag(_tx.blockTag)});return await this.#checkNetwork(this.#call(tx,blockTag,_tx.enableCcipRead?0:-1))}async#getAccountValue(request,_address,_blockTag){let address=this._getAddress(_address);let blockTag=this._getBlockTag(_blockTag);if(typeof address!=="string"||typeof blockTag!=="string"){[address,blockTag]=await Promise.all([address,blockTag])}return await this.#checkNetwork(this.#perform(Object.assign(request,{address:address,blockTag:blockTag})))}async getBalance(address,blockTag){return getBigInt(await this.#getAccountValue({method:"getBalance"},address,blockTag),"%response")}async getTransactionCount(address,blockTag){return getNumber(await this.#getAccountValue({method:"getTransactionCount"},address,blockTag),"%response")}async getCode(address,blockTag){return hexlify(await this.#getAccountValue({method:"getCode"},address,blockTag))}async getStorage(address,_position,blockTag){const position=getBigInt(_position,"position");return hexlify(await this.#getAccountValue({method:"getStorage",position:position},address,blockTag))}async broadcastTransaction(signedTx){const{blockNumber,hash,network}=await resolveProperties({blockNumber:this.getBlockNumber(),hash:this._perform({method:"broadcastTransaction",signedTransaction:signedTx}),network:this.getNetwork()});const tx=Transaction.from(signedTx);if(tx.hash!==hash){throw new Error("@TODO: the returned hash did not match")}return this._wrapTransactionResponse(tx,network).replaceableTransaction(blockNumber)}async#getBlock(block,includeTransactions){if(isHexString(block,32)){return await this.#perform({method:"getBlock",blockHash:block,includeTransactions:includeTransactions})}let blockTag=this._getBlockTag(block);if(typeof blockTag!=="string"){blockTag=await blockTag}return await this.#perform({method:"getBlock",blockTag:blockTag,includeTransactions:includeTransactions})}async getBlock(block,prefetchTxs){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#getBlock(block,!!prefetchTxs)});if(params==null){return null}return this._wrapBlock(params,network)}async getTransaction(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getTransaction",hash:hash})});if(params==null){return null}return this._wrapTransactionResponse(params,network)}async getTransactionReceipt(hash){const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getTransactionReceipt",hash:hash})});if(params==null){return null}if(params.gasPrice==null&&params.effectiveGasPrice==null){const tx=await this.#perform({method:"getTransaction",hash:hash});if(tx==null){throw new Error("report this; could not find tx or effectiveGasPrice")}params.effectiveGasPrice=tx.gasPrice}return this._wrapTransactionReceipt(params,network)}async getTransactionResult(hash){const{result}=await resolveProperties({network:this.getNetwork(),result:this.#perform({method:"getTransactionResult",hash:hash})});if(result==null){return null}return hexlify(result)}async getLogs(_filter){let filter=this._getFilter(_filter);if(isPromise$1(filter)){filter=await filter}const{network,params}=await resolveProperties({network:this.getNetwork(),params:this.#perform({method:"getLogs",filter:filter})});return params.map(p=>this._wrapLog(p,network))}_getProvider(chainId){assert$1(false,"provider cannot connect to target network","UNSUPPORTED_OPERATION",{operation:"_getProvider()"})}async getResolver(name){return await EnsResolver.fromName(this,name)}async getAvatar(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAvatar()}return null}async resolveName(name){const resolver=await this.getResolver(name);if(resolver){return await resolver.getAddress()}return null}async lookupAddress(address){address=getAddress(address);const node=namehash(address.substring(2).toLowerCase()+".addr.reverse");try{const ensAddr=await EnsResolver.getEnsAddress(this);const ensContract=new Contract(ensAddr,["function resolver(bytes32) view returns (address)"],this);const resolver=await ensContract.resolver(node);if(resolver==null||resolver===ZeroHash){return null}const resolverContract=new Contract(resolver,["function name(bytes32) view returns (string)"],this);const name=await resolverContract.name(node);const check=await this.resolveName(name);if(check!==address){return null}return name}catch(error){if(isError(error,"BAD_DATA")&&error.value==="0x"){return null}if(isError(error,"CALL_EXCEPTION")){return null}throw error}return