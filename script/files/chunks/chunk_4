y}}function normalizePrivateKey(key){let num;if(typeof key==="bigint"){num=key}else if(typeof key==="number"&&Number.isSafeInteger(key)&&key>0){num=BigInt(key)}else if(typeof key==="string"){if(key.length!==2*groupLen)throw new Error("Expected 32 bytes of private key");num=hexToNumber(key)}else if(key instanceof Uint8Array){if(key.length!==groupLen)throw new Error("Expected 32 bytes of private key");num=bytesToNumber(key)}else{throw new TypeError("Expected valid private key")}if(!isWithinCurveOrder(num))throw new Error("Expected private key: 0 < key < n");return num}function normalizePublicKey(publicKey){if(publicKey instanceof Point){publicKey.assertValidity();return publicKey}else{return Point.fromHex(publicKey)}}function normalizeSignature(signature){if(signature instanceof Signature$1){signature.assertValidity();return signature}try{return Signature$1.fromDER(signature)}catch(error){return Signature$1.fromCompact(signature)}}function getPublicKey(privateKey,isCompressed=false){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)}function recoverPublicKey(msgHash,signature,recovery,isCompressed=false){return Point.fromSignature(msgHash,signature,recovery).toRawBytes(isCompressed)}function isProbPub(item){const arr=item instanceof Uint8Array;const str=typeof item==="string";const len=(arr||str)&&item.length;if(arr)return len===compressedLen||len===uncompressedLen;if(str)return len===compressedLen*2||len===uncompressedLen*2;if(item instanceof Point)return true;return false}function getSharedSecret(privateA,publicB,isCompressed=false){if(isProbPub(privateA))throw new TypeError("getSharedSecret: first arg must be private key");if(!isProbPub(publicB))throw new TypeError("getSharedSecret: second arg must be public key");const b=normalizePublicKey(publicB);b.assertValidity();return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed)}function bits2int(bytes){const slice=bytes.length>fieldLen?bytes.slice(0,fieldLen):bytes;return bytesToNumber(slice)}function bits2octets(bytes){const z1=bits2int(bytes);const z2=mod(z1,CURVE.n);return int2octets(z2<_0n?z1:z2)}function int2octets(num){return numTo32b(num)}function initSigArgs(msgHash,privateKey,extraEntropy){if(msgHash==null)throw new Error(`sign: expected valid message hash, not "${msgHash}"`);const h1=ensureBytes(msgHash);const d=normalizePrivateKey(privateKey);const seedArgs=[int2octets(d),bits2octets(h1)];if(extraEntropy!=null){if(extraEntropy===true)extraEntropy=utils.randomBytes(fieldLen);const e=ensureBytes(extraEntropy);if(e.length!==fieldLen)throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);seedArgs.push(e)}const seed=concatBytes(...seedArgs);const m=bits2int(h1);return{seed:seed,m:m,d:d}}function finalizeSig(recSig,opts){const{sig,recovery}=recSig;const{der,recovered}=Object.assign({canonical:true,der:true},opts);const hashed=der?sig.toDERRawBytes():sig.toCompactRawBytes();return recovered?[hashed,recovery]:hashed}async function sign(msgHash,privKey,opts={}){const{seed,m,d}=initSigArgs(msgHash,privKey,opts.extraEntropy);const drbg=new HmacDrbg(hashLen,groupLen);await drbg.reseed(seed);let sig;while(!(sig=kmdToSig(await drbg.generate(),m,d,opts.canonical)))await drbg.reseed();return finalizeSig(sig,opts)}function signSync(msgHash,privKey,opts={}){const{seed,m,d}=initSigArgs(msgHash,privKey,opts.extraEntropy);const drbg=new HmacDrbg(hashLen,groupLen);drbg.reseedSync(seed);let sig;while(!(sig=kmdToSig(drbg.generateSync(),m,d,opts.canonical)))drbg.reseedSync();return finalizeSig(sig,opts)}const vopts={strict:true};function verify(signature,msgHash,publicKey,opts=vopts){let sig;try{sig=normalizeSignature(signature);msgHash=ensureBytes(msgHash)}catch(error){return false}const{r,s}=sig;if(opts.strict&&sig.hasHighS())return false;const h=truncateHash(msgHash);let P;try{P=normalizePublicKey(publicKey)}catch(error){return false}const{n}=CURVE;const sinv=invert(s,n);const u1=mod(h*sinv,n);const u2=mod(r*sinv,n);const R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2);if(!R)return false;const v=mod(R.x,n);return v===r}function schnorrChallengeFinalize(ch){return mod(bytesToNumber(ch),CURVE.n)}class SchnorrSignature{constructor(r,s){this.r=r;this.s=s;this.assertValidity()}static fromHex(hex){const bytes=ensureBytes(hex);if(bytes.length!==64)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);const r=bytesToNumber(bytes.subarray(0,32));const s=bytesToNumber(bytes.subarray(32,64));return new SchnorrSignature(r,s)}assertValidity(){const{r,s}=this;if(!isValidFieldElement(r)||!isWithinCurveOrder(s))throw new Error("Invalid signature")}toHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}toRawBytes(){return hexToBytes(this.toHex())}}function schnorrGetPublicKey(privateKey){return Point.fromPrivateKey(privateKey).toRawX()}class InternalSchnorrSignature{constructor(message,privateKey,auxRand=utils.randomBytes()){if(message==null)throw new TypeError(`sign: Expected valid message, not "${message}"`);this.m=ensureBytes(message);const{x,scalar}=this.getScalar(normalizePrivateKey(privateKey));this.px=x;this.d=scalar;this.rand=ensureBytes(auxRand);if(this.rand.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(priv){const point=Point.fromPrivateKey(priv);const scalar=point.hasEvenY()?priv:CURVE.n-priv;return{point:point,scalar:scalar,x:point.toRawX()}}initNonce(d,t0h){return numTo32b(d^bytesToNumber(t0h))}finalizeNonce(k0h){const k0=mod(bytesToNumber(k0h),CURVE.n);if(k0===_0n)throw new Error("sign: Creation of signature failed. k is zero");const{point:R,x:rx,scalar:k}=this.getScalar(k0);return{R:R,rx:rx,k:k}}finalizeSig(R,k,e,d){return new SchnorrSignature(R.x,mod(k+e*d,CURVE.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m,d,px,rand}=this;const tag=utils.taggedHash;const t=this.initNonce(d,await tag(TAGS.aux,rand));const{R,rx,k}=this.finalizeNonce(await tag(TAGS.nonce,t,px,m));const e=schnorrChallengeFinalize(await tag(TAGS.challenge,rx,px,m));const sig=this.finalizeSig(R,k,e,d);if(!await schnorrVerify(sig,m,px))this.error();return sig}calcSync(){const{m,d,px,rand}=this;const tag=utils.taggedHashSync;const t=this.initNonce(d,tag(TAGS.aux,rand));const{R,rx,k}=this.finalizeNonce(tag(TAGS.nonce,t,px,m));const e=schnorrChallengeFinalize(tag(TAGS.challenge,rx,px,m));const sig=this.finalizeSig(R,k,e,d);if(!schnorrVerifySync(sig,m,px))this.error();return sig}}async function schnorrSign(msg,privKey,auxRand){return new InternalSchnorrSignature(msg,privKey,auxRand).calc()}function schnorrSignSync(msg,privKey,auxRand){return new InternalSchnorrSignature(msg,privKey,auxRand).calcSync()}function initSchnorrVerify(signature,message,publicKey){const raw=signature instanceof SchnorrSignature;const sig=raw?signature:SchnorrSignature.fromHex(signature);if(raw)sig.assertValidity();return{...sig,m:ensureBytes(message),P:normalizePublicKey(publicKey)}}function finalizeSchnorrVerify(r,P,s,e){const R=Point.BASE.multiplyAndAddUnsafe(P,normalizePrivateKey(s),mod(-e,CURVE.n));if(!R||!R.hasEvenY()||R.x!==r)return false;return true}async function schnorrVerify(signature,message,publicKey){try{const{r,s,m,P}=initSchnorrVerify(signature,message,publicKey);const e=schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge,numTo32b(r),P.toRawX(),m));return finalizeSchnorrVerify(r,P,s,e)}catch(error){return false}}function schnorrVerifySync(signature,message,publicKey){try{const{r,s,m,P}=initSchnorrVerify(signature,message,publicKey);const e=schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge,numTo32b(r),P.toRawX(),m));return finalizeSchnorrVerify(r,P,s,e)}catch(error){if(error instanceof ShaError)throw error;return false}}const schnorr={Signature:SchnorrSignature,getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,signSync:schnorrSignSync,verifySync:schnorrVerifySync};Point.BASE._setWindowSize(8);const crypto={node:nodeCrypto,web:typeof self==="object"&&"crypto"in self?self.crypto:undefined};const TAGS={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"};const TAGGED_HASH_PREFIXES={};const utils={bytesToHex:bytesToHex,hexToBytes:hexToBytes,concatBytes:concatBytes,mod:mod,invert:invert,isValidPrivateKey(privateKey){try{normalizePrivateKey(privateKey);return true}catch(error){return false}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:hash=>{hash=ensureBytes(hash);const minLen=groupLen+8;if(hash.length<minLen||hash.length>1024){throw new Error(`Expected valid bytes of private key as per FIPS 186`)}const num=mod(bytesToNumber(hash),CURVE.n-_1n)+_1n;return numTo32b(num)},randomBytes:(bytesLength=32)=>{if(crypto.web){return crypto.web.getRandomValues(new Uint8Array(bytesLength))}else if(crypto.node){const{randomBytes}=crypto.node;return Uint8Array.from(randomBytes(bytesLength))}else{throw new Error("The environment doesn't have randomBytes function")}},randomPrivateKey:()=>utils.hashToPrivateKey(utils.randomBytes(groupLen+8)),precompute(windowSize=8,point=Point.BASE){const cached=point===Point.BASE?point:new Point(point.x,point.y);cached._setWindowSize(windowSize);cached.multiply(_3n);return cached},sha256:async(...messages)=>{if(crypto.web){const buffer=await crypto.web.subtle.digest("SHA-256",concatBytes(...messages));return new Uint8Array(buffer)}else if(crypto.node){const{createHash}=crypto.node;const hash=createHash("sha256");messages.forEach(m=>hash.update(m));return Uint8Array.from(hash.digest())}else{throw new Error("The environment doesn't have sha256 function")}},hmacSha256:async(key,...messages)=>{if(crypto.web){const ckey=await crypto.web.subtle.importKey("raw",key,{name:"HMAC",hash:{name:"SHA-256"}},false,["sign"]);const message=concatBytes(...messages);const buffer=await crypto.web.subtle.sign("HMAC",ckey,message);return new Uint8Array(buffer)}else if(crypto.node){const{createHmac}=crypto.node;const hash=createHmac("sha256",key);messages.forEach(m=>hash.update(m));return Uint8Array.from(hash.digest())}else{throw new Error("The environment doesn't have hmac-sha256 function")}},sha256Sync:undefined,hmacSha256Sync:undefined,taggedHash:async(tag,...messages)=>{let tagP=TAGGED_HASH_PREFIXES[tag];if(tagP===undefined){const tagH=await utils.sha256(Uint8Array.from(tag,c=>c.charCodeAt(0)));tagP=concatBytes(tagH,tagH);TAGGED_HASH_PREFIXES[tag]=tagP}return utils.sha256(tagP,...messages)},taggedHashSync:(tag,...messages)=>{if(typeof _sha256Sync!=="function")throw new ShaError("sha256Sync is undefined, you need to set it");let tagP=TAGGED_HASH_PREFIXES[tag];if(tagP===undefined){const tagH=_sha256Sync(Uint8Array.from(tag,c=>c.charCodeAt(0)));tagP=concatBytes(tagH,tagH);TAGGED_HASH_PREFIXES[tag]=tagP}return _sha256Sync(tagP,...messages)},_JacobianPoint:JacobianPoint};Object.defineProperties(utils,{sha256Sync:{configurable:false,get(){return _sha256Sync},set(val){if(!_sha256Sync)_sha256Sync=val}},hmacSha256Sync:{configurable:false,get(){return _hmacSha256Sync},set(val){if(!_hmacSha256Sync)_hmacSha256Sync=val}}});const ZeroAddress="0x0000000000000000000000000000000000000000";const ZeroHash="0x0000000000000000000000000000000000000000000000000000000000000000";const N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const WeiPerEther=BigInt("1000000000000000000");const MaxUint256=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const MinInt256=BigInt("0x8000000000000000000000000000000000000000000000000000000000000000")*BigInt(-1);const MaxInt256=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");const EtherSymbol="Îž";const MessagePrefix="Ethereum Signed Message:\n";const BN_0$7=BigInt(0);const BN_1$3=BigInt(1);const BN_2$3=BigInt(2);const BN_27$1=BigInt(27);const BN_28$1=BigInt(28);const BN_35$1=BigInt(35);const _guard$3={};function toUint256(value){return zeroPadValue(toBeArray(value),32)}class Signature{#r;#s;#v;#networkV;get r(){return this.#r}set r(value){assertArgument(dataLength(value)===32,"invalid r","value",value);this.#r=hexlify(value)}get s(){return this.#s}set s(_value){assertArgument(dataLength(_value)===32,"invalid s","value",_value);const value=hexlify(_value);assertArgument(parseInt(value.substring(0,3))<8,"non-canonical s","value",value);this.#s=value}get v(){return this.#v}set v(value){const v=getNumber(value,"value");assertArgument(v===27||v===28,"invalid v","v",value);this.#v=v}get networkV(){return this.#networkV}get legacyChainId(){const v=this.networkV;if(v==null){return null}return Signature.getChainId(v)}get yParity(){return this.v===27?0:1}get yParityAndS(){const yParityAndS=getBytes(this.s);if(this.yParity){yParityAndS[0]|=128}return hexlify(yParityAndS)}get compactSerialized(){return concat([this.r,this.yParityAndS])}get serialized(){return concat([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(guard,r,s,v){assertPrivate(guard,_guard$3,"Signature");this.#r=r;this.#s=s;this.#v=v;this.#networkV=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const clone=new Signature(_guard$3,this.r,this.s,this.v);if(this.networkV){clone.#networkV=this.networkV}return clone}toJSON(){const networkV=this.networkV;return{_type:"signature",networkV:networkV!=null?networkV.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId(v){const bv=getBigInt(v,"v");if(bv==BN_27$1||bv==BN_28$1){return BN_0$7}assertArgument(bv>=BN_35$1,"invalid EIP-155 v","v",v);return(bv-BN_35$1)/BN_2$3}static getChainIdV(chainId,v){return getBigInt(chainId)*BN_2$3+BigInt(35+v-27)}static getNormalizedV(v){const bv=getBigInt(v);if(bv===BN_0$7||bv===BN_27$1){return 27}if(bv===BN_1$3||bv===BN_28$1){return 28}assertArgument(bv>=BN_35$1,"invalid v","v",v);return bv&BN_1$3?27:28}static from(sig){function assertError(check,message){assertArgument(check,message,"signature",sig)}if(sig==null){return new Signature(_guard$3,ZeroHash,ZeroHash,27)}if(typeof sig==="string"){const bytes=getBytes(sig,"signature");if(bytes.length===64){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);const v=s[0]&128?28:27;s[0]&=127;return new Signature(_guard$3,r,hexlify(s),v)}if(bytes.length===65){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);assertError((s[0]&128)===0,"non-canonical s");const v=Signature.getNormalizedV(bytes[64]);return new Signature(_guard$3,r,hexlify(s),v)}assertError(false,"invalid raw signature length")}if(sig instanceof Signature){return sig.clone()}const _r=sig.r;assertError(_r!=null,"missing r");const r=toUint256(_r);const s=function(s,yParityAndS){if(s!=null){return toUint256(s)}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");const bytes=getBytes(yParityAndS);bytes[0]&=127;return hexlify(bytes)}assertError(false,"missing s")}(sig.s,sig.yParityAndS);assertError((getBytes(s)[0]&128)==0,"non-canonical s");const{networkV,v}=function(_v,yParityAndS,yParity){if(_v!=null){const v=getBigInt(_v);return{networkV:v>=BN_35$1?v:undefined,v:Signature.getNormalizedV(v)}}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");return{v:getBytes(yParityAndS)[0]&128?28:27}}if(yParity!=null){switch(yParity){case 0:return{v:27};case 1:return{v:28}}assertError(false,"invalid yParity")}assertError(false,"missing v")}(sig.v,sig.yParityAndS,sig.yParity);const result=new Signature(_guard$3,r,s,v);if(networkV){result.#networkV=networkV}assertError(!("yParity"in sig&&sig.yParity!==result.yParity),"yParity mismatch");assertError(!("yParityAndS"in sig&&sig.yParityAndS!==result.yParityAndS),"yParityAndS mismatch");return result}}utils.hmacSha256Sync=function(key,...messages){return getBytes(computeHmac("sha256",key,concat(messages)))};class SigningKey{#privateKey;constructor(privateKey){assertArgument(dataLength(privateKey)===32,"invalid private key","privateKey","[REDACTED]");this.#privateKey=hexlify(privateKey)}get privateKey(){return this.#privateKey}get publicKey(){return SigningKey.computePublicKey(this.#privateKey)}get compressedPublicKey(){return SigningKey.computePublicKey(this.#privateKey,true)}sign(digest){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const[sigDer,recid]=signSync(getBytesCopy(digest),getBytesCopy(this.#privateKey),{recovered:true,canonical:true});const sig=Signature$1.fromHex(sigDer);return Signature.from({r:toBeHex("0x"+sig.r.toString(16),32),s:toBeHex("0x"+sig.s.toString(16),32),v:recid?28:27})}computeSharedSecret(other){const pubKey=SigningKey.computePublicKey(other);console.log(pubKey);return hexlify(getSharedSecret(getBytesCopy(this.#privateKey),getBytes(pubKey)))}static computePublicKey(key,compressed){let bytes=getBytes(key,"key");if(bytes.length===32){const pubKey=getPublicKey(bytes,!!compressed);return hexlify(pubKey)}if(bytes.length===64){const pub=new Uint8Array(65);pub[0]=4;pub.set(bytes,1);bytes=pub}const point=Point.fromHex(bytes);return hexlify(point.toRawBytes(compressed))}static recoverPublicKey(digest,signature){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const sig=Signature.from(signature);const der=Signature$1.fromCompact(getBytesCopy(concat([sig.r,sig.s]))).toDERRawBytes();const pubKey=recoverPublicKey(getBytesCopy(digest),der,sig.yParity);assertArgument(pubKey!=null,"invalid signautre for digest","signature",signature);return hexlify(pubKey)}static addPoints(p0,p1,compressed){const pub0=Point.fromHex(SigningKey.computePublicKey(p0).substring(2));const pub1=Point.fromHex(SigningKey.computePublicKey(p1).substring(2));return"0x"+pub0.add(pub1).toHex(!!compressed)}}null;function lock(){computeHmac.lock();keccak256.lock();pbkdf2.lock();randomBytes.lock();ripemd160.lock();scrypt.lock();scryptSync.lock();sha256.lock();sha512.lock();randomBytes.lock()}const BN_0$6=BigInt(0);const BN_36=BigInt(36);function getChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=15;function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+"00";let expanded=address.split("").map(c=>{return ibanLookup[c]}).join("");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum="0"+checksum}return checksum}const Base36=function(){const result={};for(let i=0;i<36;i++){const key="0123456789abcdefghijklmnopqrstuvwxyz"[i];result[key]=BigInt(i)}return result}();function fromBase36(value){value=value.toLowerCase();let result=BN_0$6;for(let i=0;i<value.length;i++){result=result*BN_36+Base36[value[i]]}return result}function getAddress(address){assertArgument(typeof address==="string","invalid address","address",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith("0x")){address="0x"+address}const result=getChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,"bad address checksum","address",address);return result}if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){assertArgument(address.substring(2,4)===ibanChecksum(address),"bad icap checksum","address",address);let result=fromBase36(address.substring(4)).toString(16);while(result.length<40){result="0"+result}return getChecksumAddress("0x"+result)}assertArgument(false,"invalid address","address",address)}function getIcapAddress(address){let base36=BigInt(getAddress(address)).toString(36).toUpperCase();while(base36.length<30){base36="0"+base36}return"XE"+ibanChecksum("XE00"+base36)+base36}function getCreateAddress(tx){const from=getAddress(tx.from);const nonce=getBigInt(tx.nonce,"tx.nonce");let nonceHex=nonce.toString(16);if(nonceHex==="0"){nonceHex="0x"}else if(nonceHex.length%2){nonceHex="0x0"+nonceHex}else{nonceHex="0x"+nonceHex}return getAddress(dataSlice(keccak256(encodeRlp([from,nonceHex])),12))}function getCreate2Address(_from,_salt,_initCodeHash){const from=getAddress(_from);const salt=getBytes(_salt,"salt");const initCodeHash=getBytes(_initCodeHash,"initCodeHash");assertArgument(salt.length===32,"salt must be 32 bytes","salt",_salt);assertArgument(initCodeHash.length===32,"initCodeHash must be 32 bytes","initCodeHash",_initCodeHash);return getAddress(dataSlice(keccak256(concat(["0xff",from,salt,initCodeHash])),12))}function isAddressable(value){return value&&typeof value.getAddress==="function"}function isAddress(value){try{getAddress(value);return true}catch(error){}return false}async function checkAddress(target,promise){const result=await promise;if(result==null||result==="0x0000000000000000000000000000000000000000"){assert$1(typeof target!=="string","unconfigured name","UNCONFIGURED_NAME",{value:target});assertArgument(false,"invalid AddressLike value; did not resolve to a value address","target",target)}return getAddress(result)}function resolveAddress(target,resolver){if(typeof target==="string"){if(target.match(/^0x[0-9a-f]{40}$/i)){return getAddress(target)}assert$1(resolver!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"});return checkAddress(target,resolver.resolveName(target))}else if(isAddressable(target)){return checkAddress(target,target.getAddress())}else if(target&&typeof target.then==="function"){return checkAddress(target,target)}assertArgument(false,"unsupported addressable value","target",target)}null;const _gaurd={};function n(value,width){let signed=false;if(width<0){signed=true;width*=-1}return new Typed(_gaurd,`${signed?"":"u"}int${width}`,value,{signed:signed,width:width})}function b(value,size){return new Typed(_gaurd,`bytes${size?size:""}`,value,{size:size})}const _typedSymbol=Symbol.for("_ethers_typed");class Typed{type;value;#options;_typedSymbol;constructor(gaurd,type,value,options){if(options==null){options=null}assertPrivate(_gaurd,gaurd,"Typed");defineProperties(this,{_typedSymbol:_typedSymbol,type:type,value:value});this.#options=options;this.format()}format(){if(this.type==="array"){throw new Error("")}else if(this.type==="dynamicArray"){throw new Error("")}else if(this.type==="tuple"){return`tuple(${this.value.map(v=>v.format()).join(",")})`}return this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return this.type==="string"}get tupleName(){if(this.type!=="tuple"){throw TypeError("not a tuple")}return this.#options}get arrayLength(){if(this.type!=="array"){throw TypeError("not an array")}if(this.#options===true){return-1}if(this.#options===false){return this.value.length}return null}static from(type,value){return new Typed(_gaurd,type,value)}static uint8(v){return n(v,8)}static uint16(v){return n(v,16)}static uint24(v){return n(v,24)}static uint32(v){return n(v,32)}static uint40(v){return n(v,40)}static uint48(v){return n(v,48)}static uint56(v){return n(v,56)}static uint64(v){return n(v,64)}static uint72(v){return n(v,72)}static uint80(v){return n(v,80)}static uint88(v){return n(v,88)}static uint96(v){return n(v,96)}static uint104(v){return n(v,104)}static uint112(v){return n(v,112)}static uint120(v){return n(v,120)}static uint128(v){return n(v,128)}static uint136(v){return n(v,136)}static uint144(v){return n(v,144)}static uint152(v){return n(v,152)}static uint160(v){return n(v,160)}static uint168(v){return n(v,168)}static uint176(v){return n(v,176)}static uint184(v){return n(v,184)}static uint192(v){return n(v,192)}static uint200(v){return n(v,200)}static uint208(v){return n(v,208)}static uint216(v){return n(v,216)}static uint224(v){return n(v,224)}static uint232(v){return n(v,232)}static uint240(v){return n(v,240)}static uint248(v){return n(v,248)}static uint256(v){return n(v,256)}static uint(v){return n(v,256)}static int8(v){return n(v,-8)}static int16(v){return n(v,-16)}static int24(v){return n(v,-24)}static int32(v){return n(v,-32)}static int40(v){return n(v,-40)}static int48(v){return n