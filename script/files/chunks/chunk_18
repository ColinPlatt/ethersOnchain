ldSet$3(this,_CBC_iv,new Uint8Array(iv),"f")}else{__classPrivateFieldSet$3(this,_CBC_iv,new Uint8Array(16),"f")}__classPrivateFieldSet$3(this,_CBC_lastBlock,this.iv,"f")}get iv(){return new Uint8Array(__classPrivateFieldGet$3(this,_CBC_iv,"f"))}encrypt(plaintext){if(plaintext.length%16){throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)")}const ciphertext=new Uint8Array(plaintext.length);for(let i=0;i<plaintext.length;i+=16){for(let j=0;j<16;j++){__classPrivateFieldGet$3(this,_CBC_lastBlock,"f")[j]^=plaintext[i+j]}__classPrivateFieldSet$3(this,_CBC_lastBlock,this.aes.encrypt(__classPrivateFieldGet$3(this,_CBC_lastBlock,"f")),"f");ciphertext.set(__classPrivateFieldGet$3(this,_CBC_lastBlock,"f"),i)}return ciphertext}decrypt(ciphertext){if(ciphertext.length%16){throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)")}const plaintext=new Uint8Array(ciphertext.length);for(let i=0;i<ciphertext.length;i+=16){const block=this.aes.decrypt(ciphertext.subarray(i,i+16));for(let j=0;j<16;j++){plaintext[i+j]=block[j]^__classPrivateFieldGet$3(this,_CBC_lastBlock,"f")[j];__classPrivateFieldGet$3(this,_CBC_lastBlock,"f")[j]=ciphertext[i+j]}}return plaintext}}_CBC_iv=new WeakMap,_CBC_lastBlock=new WeakMap;var __classPrivateFieldSet$2=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet$2=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var _CFB_instances,_CFB_iv,_CFB_shiftRegister,_CFB_shift;class CFB extends ModeOfOperation{constructor(key,iv,segmentSize=8){super("CFB",key,CFB);_CFB_instances.add(this);_CFB_iv.set(this,void 0);_CFB_shiftRegister.set(this,void 0);if(!Number.isInteger(segmentSize)||segmentSize%8){throw new TypeError("invalid segmentSize")}Object.defineProperties(this,{segmentSize:{enumerable:true,value:segmentSize}});if(iv){if(iv.length%16){throw new TypeError("invalid iv size (must be 16 bytes)")}__classPrivateFieldSet$2(this,_CFB_iv,new Uint8Array(iv),"f")}else{__classPrivateFieldSet$2(this,_CFB_iv,new Uint8Array(16),"f")}__classPrivateFieldSet$2(this,_CFB_shiftRegister,this.iv,"f")}get iv(){return new Uint8Array(__classPrivateFieldGet$2(this,_CFB_iv,"f"))}encrypt(plaintext){if(8*plaintext.length%this.segmentSize){throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)")}const segmentSize=this.segmentSize/8;const ciphertext=new Uint8Array(plaintext);for(let i=0;i<ciphertext.length;i+=segmentSize){const xorSegment=this.aes.encrypt(__classPrivateFieldGet$2(this,_CFB_shiftRegister,"f"));for(let j=0;j<segmentSize;j++){ciphertext[i+j]^=xorSegment[j]}__classPrivateFieldGet$2(this,_CFB_instances,"m",_CFB_shift).call(this,ciphertext.subarray(i))}return ciphertext}decrypt(ciphertext){if(8*ciphertext.length%this.segmentSize){throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)")}const segmentSize=this.segmentSize/8;const plaintext=new Uint8Array(ciphertext);for(let i=0;i<plaintext.length;i+=segmentSize){const xorSegment=this.aes.encrypt(__classPrivateFieldGet$2(this,_CFB_shiftRegister,"f"));for(let j=0;j<segmentSize;j++){plaintext[i+j]^=xorSegment[j]}__classPrivateFieldGet$2(this,_CFB_instances,"m",_CFB_shift).call(this,ciphertext.subarray(i))}return plaintext}}_CFB_iv=new WeakMap,_CFB_shiftRegister=new WeakMap,_CFB_instances=new WeakSet,_CFB_shift=function _CFB_shift(data){const segmentSize=this.segmentSize/8;__classPrivateFieldGet$2(this,_CFB_shiftRegister,"f").set(__classPrivateFieldGet$2(this,_CFB_shiftRegister,"f").subarray(segmentSize));__classPrivateFieldGet$2(this,_CFB_shiftRegister,"f").set(data.subarray(0,segmentSize),16-segmentSize)};var __classPrivateFieldSet$1=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet$1=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var _CTR_remaining,_CTR_remainingIndex,_CTR_counter;class CTR extends ModeOfOperation{constructor(key,initialValue){super("CTR",key,CTR);_CTR_remaining.set(this,void 0);_CTR_remainingIndex.set(this,void 0);_CTR_counter.set(this,void 0);__classPrivateFieldSet$1(this,_CTR_counter,new Uint8Array(16),"f");__classPrivateFieldGet$1(this,_CTR_counter,"f").fill(0);__classPrivateFieldSet$1(this,_CTR_remaining,__classPrivateFieldGet$1(this,_CTR_counter,"f"),"f");__classPrivateFieldSet$1(this,_CTR_remainingIndex,16,"f");if(initialValue==null){initialValue=1}if(typeof initialValue==="number"){this.setCounterValue(initialValue)}else{this.setCounterBytes(initialValue)}}get counter(){return new Uint8Array(__classPrivateFieldGet$1(this,_CTR_counter,"f"))}setCounterValue(value){if(!Number.isInteger(value)||value<0||value>Number.MAX_SAFE_INTEGER){throw new TypeError("invalid counter initial integer value")}for(let index=15;index>=0;--index){__classPrivateFieldGet$1(this,_CTR_counter,"f")[index]=value%256;value=Math.floor(value/256)}}setCounterBytes(value){if(value.length!==16){throw new TypeError("invalid counter initial Uint8Array value length")}__classPrivateFieldGet$1(this,_CTR_counter,"f").set(value)}increment(){for(let i=15;i>=0;i--){if(__classPrivateFieldGet$1(this,_CTR_counter,"f")[i]===255){__classPrivateFieldGet$1(this,_CTR_counter,"f")[i]=0}else{__classPrivateFieldGet$1(this,_CTR_counter,"f")[i]++;break}}}encrypt(plaintext){var _a,_b;const crypttext=new Uint8Array(plaintext);for(let i=0;i<crypttext.length;i++){if(__classPrivateFieldGet$1(this,_CTR_remainingIndex,"f")===16){__classPrivateFieldSet$1(this,_CTR_remaining,this.aes.encrypt(__classPrivateFieldGet$1(this,_CTR_counter,"f")),"f");__classPrivateFieldSet$1(this,_CTR_remainingIndex,0,"f");this.increment()}crypttext[i]^=__classPrivateFieldGet$1(this,_CTR_remaining,"f")[__classPrivateFieldSet$1(this,_CTR_remainingIndex,(_b=__classPrivateFieldGet$1(this,_CTR_remainingIndex,"f"),_a=_b++,_b),"f"),_a]}return crypttext}decrypt(ciphertext){return this.encrypt(ciphertext)}}_CTR_remaining=new WeakMap,_CTR_remainingIndex=new WeakMap,_CTR_counter=new WeakMap;class ECB extends ModeOfOperation{constructor(key){super("ECB",key,ECB)}encrypt(plaintext){if(plaintext.length%16){throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)")}const crypttext=new Uint8Array(plaintext.length);for(let i=0;i<plaintext.length;i+=16){crypttext.set(this.aes.encrypt(plaintext.subarray(i,i+16)),i)}return crypttext}decrypt(crypttext){if(crypttext.length%16){throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)")}const plaintext=new Uint8Array(crypttext.length);for(let i=0;i<crypttext.length;i+=16){plaintext.set(this.aes.decrypt(crypttext.subarray(i,i+16)),i)}return plaintext}}var __classPrivateFieldSet=__$G&&__$G.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet=__$G&&__$G.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var _OFB_iv,_OFB_lastPrecipher,_OFB_lastPrecipherIndex;class OFB extends ModeOfOperation{constructor(key,iv){super("OFB",key,OFB);_OFB_iv.set(this,void 0);_OFB_lastPrecipher.set(this,void 0);_OFB_lastPrecipherIndex.set(this,void 0);if(iv){if(iv.length%16){throw new TypeError("invalid iv size (must be 16 bytes)")}__classPrivateFieldSet(this,_OFB_iv,new Uint8Array(iv),"f")}else{__classPrivateFieldSet(this,_OFB_iv,new Uint8Array(16),"f")}__classPrivateFieldSet(this,_OFB_lastPrecipher,this.iv,"f");__classPrivateFieldSet(this,_OFB_lastPrecipherIndex,16,"f")}get iv(){return new Uint8Array(__classPrivateFieldGet(this,_OFB_iv,"f"))}encrypt(plaintext){var _a,_b;if(plaintext.length%16){throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)")}const ciphertext=new Uint8Array(plaintext);for(let i=0;i<ciphertext.length;i++){if(__classPrivateFieldGet(this,_OFB_lastPrecipherIndex,"f")===16){__classPrivateFieldSet(this,_OFB_lastPrecipher,this.aes.encrypt(__classPrivateFieldGet(this,_OFB_lastPrecipher,"f")),"f");__classPrivateFieldSet(this,_OFB_lastPrecipherIndex,0,"f")}ciphertext[i]^=__classPrivateFieldGet(this,_OFB_lastPrecipher,"f")[__classPrivateFieldSet(this,_OFB_lastPrecipherIndex,(_b=__classPrivateFieldGet(this,_OFB_lastPrecipherIndex,"f"),_a=_b++,_b),"f"),_a]}return ciphertext}decrypt(ciphertext){if(ciphertext.length%16){throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)")}return this.encrypt(ciphertext)}}_OFB_iv=new WeakMap,_OFB_lastPrecipher=new WeakMap,_OFB_lastPrecipherIndex=new WeakMap;function pkcs7Pad(data){const padder=16-data.length%16;const result=new Uint8Array(data.length+padder);result.set(data);for(let i=data.length;i<result.length;i++){result[i]=padder}return result}function pkcs7Strip(data){if(data.length<16){throw new TypeError("PKCS#7 invalid length")}const padder=data[data.length-1];if(padder>16){throw new TypeError("PKCS#7 padding byte out of range")}const length=data.length-padder;for(let i=0;i<padder;i++){if(data[length+i]!==padder){throw new TypeError("PKCS#7 invalid padding byte")}}return new Uint8Array(data.subarray(0,length))}function looseArrayify(hexString){if(typeof hexString==="string"&&!hexString.startsWith("0x")){hexString="0x"+hexString}return getBytesCopy(hexString)}function zpad$1(value,length){value=String(value);while(value.length<length){value="0"+value}return value}function getPassword(password){if(typeof password==="string"){return toUtf8Bytes(password,"NFKC")}return getBytesCopy(password)}function spelunk(object,_path){const match=_path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);assertArgument(match!=null,"invalid path","path",_path);const path=match[1];const type=match[3];const reqd=match[4]==="!";let cur=object;for(const comp of path.toLowerCase().split(".")){if(Array.isArray(cur)){if(!comp.match(/^[0-9]+$/)){break}cur=cur[parseInt(comp)]}else if(typeof cur==="object"){let found=null;for(const key in cur){if(key.toLowerCase()===comp){found=cur[key];break}}cur=found}else{cur=null}if(cur==null){break}}assertArgument(!reqd||cur!=null,"missing required value","path",path);if(type&&cur!=null){if(type==="int"){if(typeof cur==="string"&&cur.match(/^-?[0-9]+$/)){return parseInt(cur)}else if(Number.isSafeInteger(cur)){return cur}}if(type==="number"){if(typeof cur==="string"&&cur.match(/^-?[0-9.]*$/)){return parseFloat(cur)}}if(type==="data"){if(typeof cur==="string"){return looseArrayify(cur)}}if(type==="array"&&Array.isArray(cur)){return cur}if(type===typeof cur){return cur}assertArgument(false,`wrong type found for ${type} `,"path",path)}return cur}const defaultPath$1="m/44'/60'/0'/0/0";function isKeystoreJson(json){try{const data=JSON.parse(json);const version=data.version!=null?parseInt(data.version):0;if(version===3){return true}}catch(error){}return false}function decrypt(data,key,ciphertext){const cipher=spelunk(data,"crypto.cipher:string");if(cipher==="aes-128-ctr"){const iv=spelunk(data,"crypto.cipherparams.iv:data!");const aesCtr=new CTR(key,iv);return hexlify(aesCtr.decrypt(ciphertext))}assert$1(false,"unsupported cipher","UNSUPPORTED_OPERATION",{operation:"decrypt"})}function getAccount(data,_key){const key=getBytes(_key);const ciphertext=spelunk(data,"crypto.ciphertext:data!");const computedMAC=hexlify(keccak256(concat([key.slice(16,32),ciphertext]))).substring(2);assertArgument(computedMAC===spelunk(data,"crypto.mac:string!").toLowerCase(),"incorrect password","password","[ REDACTED ]");const privateKey=decrypt(data,key.slice(0,16),ciphertext);const address=computeAddress(privateKey);if(data.address){let check=data.address.toLowerCase();if(!check.startsWith("0x")){check="0x"+check}assertArgument(getAddress(check)===address,"keystore address/privateKey mismatch","address",data.address)}const account={address:address,privateKey:privateKey};const version=spelunk(data,"x-ethers.version:string");if(version==="0.1"){const mnemonicKey=key.slice(32,64);const mnemonicCiphertext=spelunk(data,"x-ethers.mnemonicCiphertext:data!");const mnemonicIv=spelunk(data,"x-ethers.mnemonicCounter:data!");const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);account.mnemonic={path:spelunk(data,"x-ethers.path:string")||defaultPath$1,locale:spelunk(data,"x-ethers.locale:string")||"en",entropy:hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))}}return account}function getDecryptKdfParams(data){const kdf=spelunk(data,"crypto.kdf:string");if(kdf&&typeof kdf==="string"){if(kdf.toLowerCase()==="scrypt"){const salt=spelunk(data,"crypto.kdfparams.salt:data!");const N=spelunk(data,"crypto.kdfparams.n:int!");const r=spelunk(data,"crypto.kdfparams.r:int!");const p=spelunk(data,"crypto.kdfparams.p:int!");assertArgument(N>0&&(N&N-1)===0,"invalid kdf.N","kdf.N",N);assertArgument(r>0&&p>0,"invalid kdf","kdf",kdf);const dkLen=spelunk(data,"crypto.kdfparams.dklen:int!");assertArgument(dkLen===32,"invalid kdf.dklen","kdf.dflen",dkLen);return{name:"scrypt",salt:salt,N:N,r:r,p:p,dkLen:64}}else if(kdf.toLowerCase()==="pbkdf2"){const salt=spelunk(data,"crypto.kdfparams.salt:data!");const prf=spelunk(data,"crypto.kdfparams.prf:string!");const algorithm=prf.split("-").pop();assertArgument(algorithm==="sha256"||algorithm==="sha512","invalid kdf.pdf","kdf.pdf",prf);const count=spelunk(data,"crypto.kdfparams.c:int!");const dkLen=spelunk(data,"crypto.kdfparams.dklen:int!");assertArgument(dkLen===32,"invalid kdf.dklen","kdf.dklen",dkLen);return{name:"pbkdf2",salt:salt,count:count,dkLen:dkLen,algorithm:algorithm}}}assertArgument(false,"unsupported key-derivation function","kdf",kdf)}function decryptKeystoreJsonSync(json,_password){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name==="pbkdf2"){const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);return getAccount(data,key)}assert$1(params.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:params});const{salt,N,r,p,dkLen}=params;const key=scryptSync(password,salt,N,r,p,dkLen);return getAccount(data,key)}function stall$1(duration){return new Promise(resolve=>{setTimeout(()=>{resolve()},duration)})}async function decryptKeystoreJson(json,_password,progress){const data=JSON.parse(json);const password=getPassword(_password);const params=getDecryptKdfParams(data);if(params.name==="pbkdf2"){if(progress){progress(0);await stall$1(0)}const{salt,count,dkLen,algorithm}=params;const key=pbkdf2(password,salt,count,dkLen,algorithm);if(progress){progress(1);await stall$1(0)}return getAccount(data,key)}assert$1(params.name==="scrypt","cannot be reached","UNKNOWN_ERROR",{params:params});const{salt,N,r,p,dkLen}=params;const key=await scrypt(password,salt,N,r,p,dkLen,progress);return getAccount(data,key)}function getEncryptKdfParams(options){const salt=options.salt!=null?getBytes(options.salt,"options.salt"):randomBytes(32);let N=1<<17,r=8,p=1;if(options.scrypt){if(options.scrypt.N){N=options.scrypt.N}if(options.scrypt.r){r=options.scrypt.r}if(options.scrypt.p){p=options.scrypt.p}}assertArgument(typeof N==="number"&&N>0&&Number.isSafeInteger(N)&&(BigInt(N)&BigInt(N-1))===BigInt(0),"invalid scrypt N parameter","options.N",N);assertArgument(typeof r==="number"&&r>0&&Number.isSafeInteger(r),"invalid scrypt r parameter","options.r",r);assertArgument(typeof p==="number"&&p>0&&Number.isSafeInteger(p),"invalid scrypt p parameter","options.p",p);return{name:"scrypt",dkLen:32,salt:salt,N:N,r:r,p:p}}function _encryptKeystore(key,kdf,account,options){const privateKey=getBytes(account.privateKey,"privateKey");const iv=options.iv!=null?getBytes(options.iv,"options.iv"):randomBytes(16);assertArgument(iv.length===16,"invalid options.iv length","options.iv",options.iv);const uuidRandom=options.uuid!=null?getBytes(options.uuid,"options.uuid"):randomBytes(16);assertArgument(uuidRandom.length===16,"invalid options.uuid length","options.uuid",options.iv);const derivedKey=key.slice(0,16);const macPrefix=key.slice(16,32);const aesCtr=new CTR(derivedKey,iv);const ciphertext=getBytes(aesCtr.encrypt(privateKey));const mac=keccak256(concat([macPrefix,ciphertext]));const data={address:account.address.substring(2).toLowerCase(),id:uuidV4(uuidRandom),version:3,Crypto:{cipher:"aes-128-ctr",cipherparams:{iv:hexlify(iv).substring(2)},ciphertext:hexlify(ciphertext).substring(2),kdf:"scrypt",kdfparams:{salt:hexlify(kdf.salt).substring(2),n:kdf.N,dklen:32,p:kdf.p,r:kdf.r},mac:mac.substring(2)}};if(account.mnemonic){const client=options.client!=null?options.client:`ethers/${version}`;const path=account.mnemonic.path||defaultPath$1;const locale=account.mnemonic.locale||"en";const mnemonicKey=key.slice(32,64);const entropy=getBytes(account.mnemonic.entropy,"account.mnemonic.entropy");const mnemonicIv=randomBytes(16);const mnemonicAesCtr=new CTR(mnemonicKey,mnemonicIv);const mnemonicCiphertext=getBytes(mnemonicAesCtr.encrypt(entropy));const now=new Date;const timestamp=now.getUTCFullYear()+"-"+zpad$1(now.getUTCMonth()+1,2)+"-"+zpad$1(now.getUTCDate(),2)+"T"+zpad$1(now.getUTCHours(),2)+"-"+zpad$1(now.getUTCMinutes(),2)+"-"+zpad$1(now.getUTCSeconds(),2)+".0Z";const gethFilename="UTC--"+timestamp+"--"+data.address;data["x-ethers"]={client:client,gethFilename:gethFilename,path:path,locale:locale,mnemonicCounter:hexlify(mnemonicIv).substring(2),mnemonicCiphertext:hexlify(mnemonicCiphertext).substring(2),version:"0.1"}}return JSON.stringify(data)}function encryptKeystoreJsonSync(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=scryptSync(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64);return _encryptKeystore(getBytes(key),kdf,account,options)}async function encryptKeystoreJson(account,password,options){if(options==null){options={}}const passwordBytes=getPassword(password);const kdf=getEncryptKdfParams(options);const key=await scrypt(passwordBytes,kdf.salt,kdf.N,kdf.r,kdf.p,64,options.progressCallback);return _encryptKeystore(getBytes(key),kdf,account,options)}const defaultPath="m/44'/60'/0'/0/0";const MasterSecret=new Uint8Array([66,105,116,99,111,105,110,32,115,101,101,100]);const HardenedBit=2147483648;const N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const Nibbles="0123456789abcdef";function zpad(value,length){let result="";while(value){result=Nibbles[value%16]+result;value=Math.trunc(value/16)}while(result.length<length*2){result="0"+result}return"0x"+result}function encodeBase58Check(_value){const value=getBytes(_value);const check=dataSlice(sha256(sha256(value)),0,4);const bytes=concat([value,check]);return encodeBase58(bytes)}const _guard={};function ser_I(index,chainCode,publicKey,privateKey){const data=new Uint8Array(37);if(index&HardenedBit){assert$1(privateKey!=null,"cannot derive child of neutered node","UNSUPPORTED_OPERATION",{operation:"deriveChild"});data.set(getBytes(privateKey),1)}else{data.set(getBytes(publicKey))}for(let i=24;i>=0;i-=8){data[33+(i>>3)]=index>>24-i&255}const I=getBytes(computeHmac("sha512",chainCode,data));return{IL:I.slice(0,32),IR:I.slice(32)}}function derivePath(node,path){const components=path.split("/");assertArgument(components.length>0&&(components[0]==="m"||node.depth>0),"invalid path","path",path);if(components[0]==="m"){components.shift()}let result=node;for(let i=0;i<components.length;i++){const component=components[i];if(component.match(/^[0-9]+'$/)){const index=parseInt(component.substring(0,component.length-1));assertArgument(index<HardenedBit,"invalid path index",`path[${i}]`,component);result=result.deriveChild(HardenedBit+index)}else if(component.match(/^[0-9]+$/)){const index=parseInt(component);assertArgument(index<HardenedBit,"invalid path index",`path[${i}]`,component);result=result.deriveChild(index)}else{assertArgument(false,"invalid path component",`path[${i}]`,component)}}return result}class HDNodeWallet extends BaseWallet{publicKey;fingerprint;parentFingerprint;mnemonic;chainCode;path;index;depth;constructor(guard,signingKey,parentFingerprint,chainCode,path,index,depth,mnemonic,provider){super(signingKey,provider);assertPrivate(guard,_guard,"HDNodeWallet");defineProperties(this,{publicKey:signingKey.compressedPublicKey});const fingerprint=dataSlice(ripemd160(sha256(this.publicKey)),0,4);defineProperties(this,{parentFingerprint:parentFingerprint,fingerprint:fingerprint,chainCode:chainCode,path:path,index:index,depth:depth});defineProperties(this,{mnemonic:mnemonic})}connect(provider){return new HDNodeWallet(_guard,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,provider)}#account(){const account={address:this.address,privateKey:this.privateKey};const m=this.mnemonic;if(this.path&&m&&m.wordlist.locale==="en"&&m.password===""){account.mnemonic={path:this.path,locale:"en",entropy:m.entropy}}return account}async encrypt(password,progressCallback){return await encryptKeystoreJson(this.#account(),password,{progressCallback:progressCallback})}encryptSync(password){return encryptKeystoreJsonSync(this.#account(),password)}get extendedKey(){assert$1(this.depth<256,"Depth too deep","UNSUPPORTED_OPERATION",{operation:"extendedKey"});return encodeBase58Check(concat(["0x0488ADE4",zpad(this.depth,1),this.parentFingerprint,zpad(this.index,4),this.chainCode,concat(["0x00",this.privateKey])]))}hasPath(){return this.path!=null}neuter(){return new HDNodeVoidWallet(_guard,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)}deriveChild(_index){const index=getNumber(_index,"index");assertArgument(index<=4294967295,"invalid index","index",index);let path=this.path;if(path){path+="/"+(index&~HardenedBit);if(index&HardenedBit){path+="'"}}const{IR,IL}=ser_I(index,this.chainCode,this.publicKey,this.privateKey);const ki=new SigningKey(toBeHex((toBigInt(IL)+BigInt(this.privateKey))%N,32));return new HDNodeWallet(_guard,ki,this.fingerprint,hexlify(IR),path,index,this.depth+1,this.mnemonic,this.provider)}derivePath(path){return derivePath(this,path)}static#fromSeed(_seed,mnemonic){assertArgument(isBytesLike(_seed),"invalid seed","seed","[REDACTED]");const seed=getBytes(_seed,"seed");assertArgument(seed.length>=16&&seed.length<=64,"invalid seed","seed","[REDACTED]");const I=getBytes(computeHmac("sha512",MasterSecret,seed));const signingKey=new SigningKey(hexlify(I.slice(0,32)));return new HDNodeWallet(_guard,signingKey,"0x00000000",hexlify(I.slice(32)),"m",0,0,mnemonic,null)}static fromExtendedKey(exten